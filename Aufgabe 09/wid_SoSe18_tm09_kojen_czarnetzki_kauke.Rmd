---
title: "Wissensentdeckung in Datenbanken SoSe 2018"
subtitle: "Übungsblatt 09"
author: "Alexander Kojen, Robin Czarnetzki, Jonas Kauke"  # Hier die Namen aller Gruppenmitglieder eintragen!
output: pdf_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) # Code wird ausgegeben
library("MASS")
library("mlr")
library("mlbench")
library("caTools")
        # die Pakete muessen gegebenenfalls installiert werden!
```

## Aufgabe 1

### a)
Learner
```{r}
# Wenden Sie die folgenden Lernverfahren mit mlr auf die Datensätze an: Naive Bayes,
# kNN mit k = 3 und mit k = 21, SVM mit linearem und mit radialem Kern, AdaBoost, Entscheidungsbaum
# und Random Forest mit 5 und mit 500 Bäumen. Visualisieren Sie die Entscheidungsgrenzen
# (plotLearnerPrediction)

#Daten:
normals <- mlbench.2dnormals(500, 2)
circles <- mlbench.circle(500, 2)
spirals <- mlbench.spirals(500, cycles = 2)


```
Tasks
```{r}
#to do: Wie in älteren Übungen. Tasks & Learner in liste packen und dann (mit Schleife?) plotten 
normalsTask = makeClassifTask(data = normals, target = "Class")
model = train(makeLearner("classif.naiveBayes"), task)

```


Plots
```{r, fig.pos = "p", fig.height = 4}

```


### b)




## Aufgabe 2
```{r}
S <- matrix(c(5, 2, 2, 2), nrow = 2)
```

### a)
```{r}
```
Die Hauptkomponenten lauten
$$
z_1 = 
$$
$$
z_2 =
$$
Der Anteil der durch die erste Hauptkomponente erklärten Varianz ergibt sich durch:
```{r}

```




### b)
Korrelationsmatrix
```{r}


```


```{r}
```
Hauptkomponenten bzw. Scores $z_1$ und $z_2$:
$$
z_1 = 
$$
$$
z_2 = 
$$

Varianzanteil
```{r}

```

### c)


## Aufgabe 3
Einlesen der Daten
```{r}
daten <- read.table("bank.txt")
```

### a)
HKA auf Basis von Kovarianzen:
```{r}

```

HKA auf Basis von Korrelationen:
```{r}

```

### b)

Screeplot
```{r}

```

Anteil an der Gesamtvarianz
```{r}

```

### c)
Biplot
```{r}

```


Interpretation:

## Aufgabe 4

### a)
Es handelt sich dabei um autoregressive Prozesse 1-ter Ordnung.
Dabei sind, aufgrund der Vorraussetzung von |ß_2| < 1 (F. 396, Zeitreihenanalyse.pdf), der 1. Prozess stationär, der 2. Prozess dagegen nicht.

### b)
Funktion zum Simulieren
```{r}
#F. 398:
erwWert1 <- 1 / (1-(-0.9))
#zeitReihe1 <- arima.sim(n = 500, list(ar = c(1, -0.9), ma = c(-0.2279, 0.2488)),
          sd = sqrt(0.1796))

```

Simulation
```{r}

```

Darstellung
```{r}

```


### c)
Glätten mit einem einfachen gleitenden Durchschnitt
```{r}

```




